# _cpu_

#### 冯诺依曼体系结构有以下特点：

1. 计算机处理的数据和指令一律用二进制数表示；
2. 指令和数据不加区别混合存储在同一个存储器中；
3. 顺序执行程序的每一条指令；
4. 计算机硬件由运算器、控制器、存储器、输入设备和输出设备五大部分组成。

##### 冯诺依曼体系结构的计算机必须具有如下功能：

* 把需要的程序和数据送至计算机中；
* 必须具有长期记忆程序、数据、中间结果及最终运算结果的能力；
* 能够完成各种算术、逻辑运算和数据传送等数据加工处理的能力；
* 能够根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；
* 能够按照要求将处理结果输出给用户。

![](blob:file:///45ec0e69-3c82-4b64-b29d-607e1a15d9ca)

CPU的两个主要组成是控制器和运算器，当然新型的CPU也集成了高速缓存和浮点处理器等部件。控制器是整个系统的指挥中心，控制运算器，存储器和输入输出设备的工作情况，它主要包括程序计数器（PC）、指令寄存器（IR）、指令译码器（ID）、时序发生器和操作控制器。

现代CPU的缓存结构一般分三层，L1，L2和L3。如下图所示：级别越小的缓存，越接近CPU， 意味着速度越快且容量越少。

L1是最接近CPU的，它容量最小，速度最快，每个核上都有一个L1 Cache\(准确地说每个核上有两个L1 Cache， 一个存数据 L1d Cache， 一个存指令 L1i Cache\)；

L2 Cache 更大一些，例如256K，速度要慢一些，一般情况下每个核上都有一个独立的L2 Cache；

L3 Cache是三级缓存中最大的一级，例如12MB，同时也是最慢的一级，在同一个CPU插槽之间的核共享一个L3 Cache。

![](/assets/importcuc.png)

# 计算机工作原理 {#22-计算机工作原理}

对于我们现代计算机来说，最关键的2个部件就是CPU和内存。内存存储了要执行的程序指令，而CPU就是用来执行这些指令。CPU首先要知道这些指定存放在存储器的那个区域，然后才能执行，并且把执行的结果写入到执行区域。

### CPU指令 {#221-cpu指令和编程语言}

因为在计算机中指令和数据都用二进制来表示，也就是说它只认识0和1这样的数字。最早期的计算机程序通过在纸带上打洞来人工操操作的方式来模拟0和1，根据不同的组合来完成一些操作。后来直接通过0和1编程程序，这种称之为机器语言,CPU指令其实就对应了我们这里说的0和1的一些组合,

每款CPU在设计时就规定了一系列与其硬件电路相配合的指令系统。有了CPU指令集的文档你就可以通过这个编写CPU认识的机器代码了。所以对于不同CPU来说可能会有不同的机器码。比如下面我们就定义了一套我们CPU硬件电路可以完成的CPU指令。![](/assets/importzhiling.png)

### 编程语言

使用0和1这样的机器语言好处是CPU认识，可以直接执行，但是对于程序本身来说，没有可读性，难以维护，容易出错。所以就出现了**汇编语言**，它用助记符\(代替操作码指令，用地址符号代替地址码。实际是对机器语言的一种映射，可读性高。![](/assets/import汇编.png)把汇编语言转换为机器语言需要一个叫做**汇编器**的工具。对于目前的CPU厂商，在推出的CPU指令时都会同时退出新的汇编器。如果你还在使用老版本的汇编器那么只能使用机器码来使用新的指令了。

汇编语言的出现大大提高了编程效率，但是有一个问题就是不同CPU的指令集可能不同，这样就需要为不同的CPU编写不同的汇编程序。于是又出现了**高级语言**比如C，或者是后来的C++,[Java](http://lib.csdn.net/base/javase),C\#。 高级语言把多条汇编指令合成成为了一个表达式，并且去除了许多操作细节（比如堆栈操作，寄存器操作），而是以一种更直观的方式来编写程序，而面向对象的语言的出现使得程序编写更加符合我们的思维方式。我们不必把尽力放到低层的细节上，而更多的关注程序的本身的逻辑的实现。

对于高级语言来说需要一个**编译器**来完成高级语言到汇编语言的转换。所以对比不同的CPU结构，只需要有不同编译器和汇编器就能使得我们的程序在不同CPU上都能运行了。如下图在VS2010中，我们可以选择程序编译的目标平台，X86，X64，ARM等。当然除了这些编译类的语言之外还有解释类型的语言如JS，就不在此讨论范围内。

#### CPU工作流程 {#2223-cpu工作流程}

以前CPU主要由**运算器**和**控制器**两大部分组成，随着集成电路的发展，目前CPU芯片集成了一些其它逻辑功能部件来扩充CPU的功能，如浮点运算器、内存管理单元、cache和MMX等。对于一个通用的CPU来说，我们只需要关注他的核心部**件算数逻辑单元和操作控制单元**。

CPU的基本工作是执行存储的指令序列，即程序。程序的执行过程实际上是不断地取出指令、分析指令、执行指令的过程。几乎所有的冯•诺伊曼型计算机的CPU，其工作都可以分为5个阶段：取指令、指令译码、执行指令、访存取数和结果写回。![](/assets/importcpuzhi.png)

### CPU与线程关系

### cpu与核心

##### 物理核 {#物理核}

物理核数量=cpu数\(机子上装的cpu的数量\)\*每个cpu的核心数

##### 虚拟核 {#虚拟核}

所谓的4核8线程，4核指的是物理核心。通过超线程技术，用一个物理核模拟两个虚拟核，每个核两个线程，总数为8线程。

在操作系统看来是8个核，但是实际上是4个物理核。

通过超线程技术可以实现单个物理核实现线程级别的并行计算，但是比不上性能两个物理核。

##### 单核cpu和多核cpu {#单核cpu和多核cpu}

* 都是一个cpu，不同的是每个cpu上的核心数
* 多核cpu是多个单核cpu的替代方案，多核cpu减小了体积，同时也减少了功耗
* 一个核心只能同时执行一个线程

### 多核下线程数量选择 {#多核下线程数量选择}

##### 计算密集型 {#计算密集型}

* 程序主要为复杂的逻辑判断和复杂的运算。

* cpu的利用率高，不用开太多的线程，开太多线程反而会因为线程切换时切换上下文而浪费资源。

##### IO密集型 {#io密集型}

* 程序主要为IO操作，比如磁盘IO\(读取文件\)和网络IO\(网络请求\)。

* 因为IO操作会阻塞线程，cpu利用率不高，可以开多点线程，阻塞时可以切换到其他就绪线程，提高cpu利用率。

提高性能的一种方式：提高硬件水平，处理速度或核心数。

另一种方式：根据场景，合理设置线程数，软件上提高cpu利用率。

## 处理器调度算法

1. **先来先服务（First Come First Served，FCFS ）**

   最简单的调度算法，即可用于作业调度，也可用于进程调度。按作业（进程）来到的先后次序进行调度。

   优点：易于实现  
   缺点：调度程序每次选择的作业是等待时间最久的，而不管作业的运行时间的长短，此算法效率低；有利于长作业，不利于短作业

2. **最短作业（进程）优先算法**

SJF：Shortest Job First  
SPF：Shortest Process First

可用于作业调度和进程调度。

估计作业（进程）的CPU运行时间，选取估计时间最短的作业（进程）投入运行。

优点：

\(1\)易于实现。

\(2\)在一般情况下这种调度算法比先来先服务调度算法的调度性能比FCFS好。 

缺点：

* 作业（进程）的执行时间是用户估计的，不一定准确，所以实现时不一定真正做到短作业优先调度。
  对长作业不利  ，若系统不断接受新作业，就有可能使长作业长时间得不到调度。出现饥饿现象   缺少剥夺机制，对分时、实时系统仍不理想

1. **响应比最高者优先算法**
2. **优先级调度算法**
3. **时间片轮转调度算法\(Round Robin，RR\)**
4. **多级反馈队列调度算法**



